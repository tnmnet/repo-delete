#!/bin/bash
# Parameters:
# Workspace label, used to distinguish between different environments.
#   The workspace needs to be configured in the global configuration file,
#   also, the secrets file for the workspace need to exist.
#   Syntax: -w {name of the label}
# Build direction, used to either build the demo or destroy it.
#   Values can be either up (-u) or down (-d).
#   Syntax: -u|-d
# 
# More information at:
# https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar
# https://www.youtube.com/watch?v=xUuJhgDbUJQ
# https://learn.hashicorp.com/vault/kubernetes/sidecar
# https://medium.com/hashicorp-engineering/hashicorp-vault-delivering-secrets-with-kubernetes-1b358c03b2a3
# https://www.vaultproject.io/docs/platform/k8s/injector/annotations


# Figure out where we are
ORIGIN_PATH=$(pwd)
SCRIPT_PATH=$(cd $(dirname $0); pwd)
ROOT_PATH=$SCRIPT_PATH/..

CONFIG_PATH=$ROOT_PATH/config
[[ ! -d "$CONFIG_PATH" ]] && { echo $'\e[1;31m'"ERROR>>> Configuration volume not mounted at '$CONFIG_PATH', exiting!"$'\e[0m' >&2; exit 1; }
export CONFIG_FILE=$CONFIG_PATH/config.yaml
[[ ! -f "$CONFIG_FILE" ]] && { echo $'\e[1;31m'"ERROR>>> Missing configuration file at '$CONFIG_FILE', exiting!"$'\e[0m' 1>&2 ; exit 1; }
export SECRETS_FILE=$CONFIG_PATH/secrets.yaml
[[ ! -f "$SECRETS_FILE" ]] && { echo $'\e[1;31m'"ERROR>>> Missing secrets file at '$SECRETS_FILE', exiting!"$'\e[0m' 1>&2 ; exit 1; }

source $ROOT_PATH/functions

# Parse parameters
BUILD=
WORKSPACE=
parse_args

# Verify configuration
DIR_LOCAL_CACHE=
DIR_LOCAL_CACHE_WKS=
DIR_LOCAL_CACHE_TF=
FILE_GENERATED_CONFIG=
PROVIDER=
CLUSTER_TYPE=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=
verify_common_conf $WORKSPACE

KUBECONFIG=$DIR_LOCAL_CACHE_WKS/kube-config
[[ ! -f "$KUBECONFIG" ]] && { echo $'\e[1;31m'"ERROR>>> Missing kube-config file for workspace '$WORKSPACE', exiting!"$'\e[0m' 1>&2 ; exit 1; }
export KUBECONFIG

verify_conf_value $FILE_GENERATED_CONFIG "workspaces.(name==$WORKSPACE).ingress.public-address"
INGRESS_PUBLIC_DNS=$verify_conf_value_retval

verify_conf_value $CONFIG_FILE "kubernetes-components.(name==vault).public-dns-prefix"
DNS_PREFIX_VAULT=$verify_conf_value_retval


# ---------------------------------------------------------
# Run actual scripts
build_up ()
{
  set -e
  echo Installating Vault for workspace \'$WORKSPACE\'...

  echo Installing Vault Helm chart...
  helm repo add hashicorp https://helm.releases.hashicorp.com
  helm repo update
  helm install vault hashicorp/vault -f $SCRIPT_PATH/vault-config.yaml > /dev/null
  sleep 5
  echo Installing Vault Helm chart...success.
  
  # Ingress
  echo Configuring Vault ingress...
  cat $SCRIPT_PATH/vault-ingress.yaml.tmpl | \
    sed 's/\$INGRESS_PUBLIC_DNS'"/$INGRESS_PUBLIC_DNS/g" | \
    sed 's/\$DNS_PREFIX_VAULT'"/$DNS_PREFIX_VAULT/g" | \
    kubectl apply -f -
  sleep 10
  echo Configuring Vault ingress...success.
  
  # Kubernetes authentication
  echo Configuring Vault authentication and access role...
  export VAULT_ADDR=http://$DNS_PREFIX_VAULT.$INGRESS_PUBLIC_DNS
  
  # Login for further work using 'root' token
  vault login root
  
  # Add simple demo policy (but is not secure, restrict in production)
  echo "path \"secret*\" { capabilities = [\"read\"] }" | vault policy write devops-demo -
  
  # Enable Kubernetes authentication method
  vault auth enable kubernetes
  
  # Get token and cert for the Vault ServiceAccount in Kubernetes (Vault ServiceAccount was created by the Helm installation)
  VAULT_K8S_TOKEN=$(kubectl get secret \
    $(kubectl get serviceaccount vault -o jsonpath="{.secrets[0].name}") \
    -o jsonpath="{.data.token}" \
    | base64 --decode \
    )
  VAULT_K8S_CERT=$(kubectl get secret \
    $(kubectl get serviceaccount vault -o jsonpath="{.secrets[0].name}") \
    -o jsonpath="{['data']['ca\.crt']}" \
    | base64 --decode \
    )

  # Configure Kubernetes authentication method:
  # - instructs Vault to ask Kubernetes TokenReview API if the token presented by an app is valid
  K8S_API_SERVER=$(kubectl config view -o jsonpath="{.clusters[0].cluster.server}")
  vault write auth/kubernetes/config \
    token_reviewer_jwt=$VAULT_K8S_TOKEN \
    kubernetes_ca_cert="$VAULT_K8S_CERT" \
    kubernetes_host=$K8S_API_SERVER

  # Create role in Vault that allows access to the secret
  # ServiceAccount name needs to match the name that will be used for an application's ServiceAccount
  # Policy name needs to match the policy created above
  # This would normally be configured out of band
  vault write auth/kubernetes/role/devops-demo-app \
    bound_service_account_names=devops-demo-app \
    bound_service_account_namespaces=default \
    policies=devops-demo \
    ttl=5

  # Add a simple default secrets that can be used in an app right away
  vault kv put secret/helloworld username=hello password=world

  echo Configuring Vault authentication and access role...success.

  echo Installating Vault for workspace \'$WORKSPACE\'...success.

  echo
  echo $'\e[1;34m'Vault reachable at: $DNS_PREFIX_VAULT.$INGRESS_PUBLIC_DNS$'\e[0m'
  echo "Use 'root' as the login token in the user interface."
  echo "A simple sample secret for demoing/testing has been added to Vault:"
  echo "Name: secret/helloworld"
  echo "Values: username=hello, password=world"
  echo
  return 0
}

tear_down ()
{
  echo Removing Vault for workspace \'$WORKSPACE\'...

  # Remove ingress
  echo Deleting Vault ingress...
  cat $SCRIPT_PATH/vault-ingress.yaml.tmpl | \
    sed 's/\$INGRESS_PUBLIC_DNS'"/$INGRESS_PUBLIC_DNS/g" | \
    sed 's/\$DNS_PREFIX_VAULT'"/$DNS_PREFIX_VAULT/g" | \
    kubectl delete -f -
  echo Deleting Vault ingress...success.
  # Remove Helm chart and repo
  echo Removing Vault Helm chart...
  helm delete vault
  helm repo remove hashicorp
  echo Removing Vault Helm chart...success.

  echo Removing Vault for workspace \'$WORKSPACE\'...success.
  return 0
}

# Build up or tear down based on build direction
case $BUILD in
  u)
    build_up
    ;;
  d)
    tear_down
    ;;
esac

# All done
cd $ORIGIN_PATH
