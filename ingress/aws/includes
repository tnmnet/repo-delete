# Verify configuration parameters specific for AWS as a sanity check and fail-fast.
# Parameters:
#   1) path of the configuration file
#   2) path of the secrets configuration file
#   3) workspace label
# Return:
#   sets global constants
verify_configuration ()
{
  # Check presence of CLI
  verify_tool "aws"

  # Backend configuration
  verify_conf_value $CONFIG_FILE_SECRETS "backend.access-key"
  BACKEND_ACCESS_KEY=$verify_conf_value_retval

  verify_conf_value $CONFIG_FILE_SECRETS "backend.secret-key"
  BACKEND_SECRET_KEY=$verify_conf_value_retval

  verify_conf_value $CONFIG_FILE "workspaces.(name==$WORKSPACE).backend.region"
  BACKEND_REGION=$verify_conf_value_retval

  verify_conf_value $FILE_GENERATED_CONFIG "workspaces.(name==$WORKSPACE).backend.bucket-id"
  BACKEND_BUCKET_ID=$verify_conf_value_retval

  verify_conf_value $FILE_GENERATED_CONFIG "workspaces.(name==$WORKSPACE).backend.lock-table-id"
  BACKEND_LOCK_TABLE_ID=$verify_conf_value_retval

  verify_conf_value $CONFIG_FILE_SECRETS "kubernetes.access-key"
  ACCESS_KEY=$verify_conf_value_retval
  # Need to export this for AWS Authenticator to work
  export AWS_ACCESS_KEY_ID=$ACCESS_KEY

  verify_conf_value $CONFIG_FILE_SECRETS "kubernetes.secret-key"
  SECRET_KEY=$verify_conf_value_retval
  # Need to export this for AWS Authenticator to work
  export AWS_SECRET_ACCESS_KEY=$SECRET_KEY

  verify_conf_value $CONFIG_FILE "workspaces.(name==$WORKSPACE).kubernetes.region"
  REGION=$verify_conf_value_retval

  verify_conf_value $CONFIG_FILE "workspaces.(name==$WORKSPACE).ingress.dns-zone"
  DNS_ZONE=$verify_conf_value_retval

  verify_conf_value $CONFIG_FILE "workspaces.(name==$WORKSPACE).ingress.public-dns-prefix"
  INGRESS_CTR_PUBLIC_ADR_PREFIX=$verify_conf_value_retval

  return 0
}

# Returns the json path to determine the IP address or domain name
# of the load balancer for the ingress controller
lb_address ()
{
  lb_address_retval="$(kubectl get services -o jsonpath='{.items[*].status.loadBalancer.ingress[0].hostname'})"
  return 0
}

# Executes the script.
# Make sure variables are set accordingly.
build_ingress ()
{
  cd $DIR_LOCAL_CACHE_TF_DNS_RECORD
  if [ ! "$(ls -A $DIR_LOCAL_CACHE_TF_DNS_RECORD)" ]; then
    terraform init -from-module $SCRIPT_PATH/$PROVIDER \
      -backend-config="bucket=$BACKEND_BUCKET_ID" \
      -backend-config="region=$BACKEND_REGION" \
      -backend-config="dynamodb_table=$BACKEND_LOCK_TABLE_ID" \
      -backend-config="access_key=$BACKEND_ACCESS_KEY" \
      -backend-config="secret_key=$BACKEND_SECRET_KEY"
  fi
  terraform apply -auto-approve \
    -var="aws_access_key=$ACCESS_KEY" \
    -var="aws_secret_key=$SECRET_KEY" \
    -var="aws_region=$REGION" \
    -var="ingress_lb_dns=$INGRESS_CTR_LB_ADR" \
    -var="subdomain_prefix=$INGRESS_CTR_PUBLIC_ADR_PREFIX" \
    -var="zone_name=$DNS_ZONE" \
    -var="environment=$WORKSPACE"

  return 0
}

# Destroys the ingress controller.
destroy_ingress ()
{
  cd $DIR_LOCAL_CACHE_TF_DNS_RECORD
  terraform destroy -auto-approve \
    -var="aws_access_key=$ACCESS_KEY" \
    -var="aws_secret_key=$SECRET_KEY" \
    -var="aws_region=$REGION" \
    -var="ingress_lb_dns=$INGRESS_CTR_LB_ADR" \
    -var="subdomain_prefix=$INGRESS_CTR_PUBLIC_ADR_PREFIX" \
    -var="zone_name=$DNS_ZONE" \
    -var="environment=$WORKSPACE"

  return 0
}
